enum GroupType {
  CLASS
  TEAM
  COORDINATION
}

type Mutation {
  addMember(
    name: String
    username: String
    email: String
    institution: String
    type: String
    title: String
    bio: String
  ): String @function(name: "createMember-${env}")
}

"""
These are institutions that are partnered with Shuddhi Vidhya
These could be schools, colleges, corporates, organisations etc.
They contain information like name, website, who the admins are,
what classes/departments they contain
"""
type Institution
  @model
  @searchable
  @auth(
    rules: [
      {
        allow: groups
        groups: ["SUPER_ADMIN"]
        operations: [create, update, delete]
      }
    ]
  ) {
  id: ID!

  "Name of the institution"
  name: String!

  "Location of the institution"
  location: String!

  "City or district that the institution belongs to"
  city: String!

  "Website URL"
  website: String

  "Phone number"
  phone: String

  "Logo URL"
  logo: String

  "Short bio, could be their school motto"
  bio: String

  "ids of the admins of this institution"
  adminIds: [String]

  "Admins of the institution manage the institution's properties"
  admins: [Member]
    @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }])
    @connection(fields: ["adminIds"])

  "Ids of the members of the institution"
  memberIds: [String]
  "All Members belonging to the institution"
  members: [Member]
    @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }])
    @connection(fields: ["memberIds"])

  "Search Field for searching the entire table for a string"
  searchField: String
}

"""
Announcements to members and groups.
This can be created by certain user groups and
audience can be specified for each announcement.
"""
type Announcement
  @model
  @auth(
    rules: [
      { allow: groups, groups: ["SUPER_ADMIN"] }
      {
        allow: owner
        ownerField: "author"
        operations: [create, update, delete]
      }
    ]
  ) {
  id: ID!

  "Title of the announcement"
  title: String!

  "The user id of the author"
  authorId: String!

  "The person who is making the announcement"
  author: Member! @connection(fields: ["authorId"])

  "Message of the announcement"
  message: String!

  "The person who is making the announcement"
  recipentIds: [String]

  "List of members that the announcement should be delivered to"
  recipients: [Member] @connection(fields: ["recipientIds"])

  "The Ids of the groups that this announcement is for"
  groupIds: [String]

  "List of groups that this announcement should be delivered to"
  groups: [Group] @connection(fields: ["groupIds"])

  "Search Field for searching the entire table for a string"
  searchField: String
}

"""
Groups of students. Groups can be of these types - class, team or coordinators.
"""
type Group
  @model
  @auth(
    rules: [
      { allow: groups, groups: ["SUPER_ADMIN"] }
      { allow: owner, ownerField: "admins", operations: [update, read] }
    ]
  ) {
  id: ID!

  "Name of the group"
  name: String!

  "The id of the insitition that this group belongs to"
  institution: Institution!

  "Type of group this is. It can be Class, Team or Coordinators."
  type: GroupType!

  "ids of the admins of this group"
  adminIds: [String]

  "The admins of the group who can manage members of the class etc"
  admins: [Member]
    @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }])
    @connection(fields: ["adminIds"])

  "List of members in this group"
  members: [GroupMember]
    @connection(keyName: "GroupMemberConnection", fields: ["id"])

  "Search Field for searching the entire table for a string"
  searchField: String
}

type Member
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: groups, groups: ["SUPER_ADMIN"], operations: [create, delete] }
      { allow: owner, ownerField: "id", operations: [update] }
    ]
  ) {
  id: ID!

  "Name of the person"
  name: String!

  "Email ID of the person"
  email: String!
    @auth(
      rules: [{ allow: owner, ownerField: "id", operations: [read, update] }]
    )

  "Type of the user, i.e. the Cognito User pool group"
  type: String!

  "Title of the person"
  title: String

  "Bio of the person"
  bio: String

  "ids of the institution that this member belongs to"
  institutionId: String

  "Every member will be tied to an institution, instructors, course assistants will be tied to Shuddhi Vidhya"
  institution: Institution!
    @auth(
      rules: [{ allow: groups, groups: ["SUPER_ADMIN"], operations: [update] }]
    )
    @connection(fields: ["institutionId"])

  "Groups that this member belongs in"
  groups: [GroupMember]
    @connection(keyName: "MemberGroupConnection", fields: ["id"])

  "Courses they are instructors in"
  instructor: [CourseInstructor]
    @connection(keyName: "InstructorCourseConnection", fields: ["id"])

  "Courses that they are assistants in"
  assistant: [CourseAssistant]
    @connection(keyName: "AssistantCourseConnection", fields: ["id"])

  "Courses that they are learners in"
  learner: [CourseLearner]
    @connection(keyName: "LearnerCourseConnection", fields: ["id"])

  "Search Field for searching the entire table for a string"
  searchField: String
}

"""
Courses are created by instructors
"""
type Course
  @model
  @auth(
    rules: [
      { allow: groups, groups: ["SUPER_ADMIN"] }
      {
        allow: owner
        ownerField: "instructors"
        operations: [create, update, read]
      }
    ]
  ) {
  id: ID!

  "Instructor(s) of the course"
  instructors: [CourseInstructor!]!
    @connection(keyName: "CourseInstructorConnection", fields: ["id"])

  "Those who will be assisting with the course"
  assistants: [CourseAssistant]
    @connection(keyName: "CourseAssistantConnection", fields: ["id"])

  "Those who are participating as learners in the course"
  learners: [CourseLearner]
    @connection(keyName: "CourseLearnerConnection", fields: ["id"])

  "When the course starts"
  start: AWSDate

  "When the course is expected to end"
  end: AWSDate

  "Number of hours the learners are expected to invest per week"
  creditHours: Int

  "The assignments' ids"
  assignmentIds: [String]

  "Assignments that are part of this course"
  assignments: [Assignment] @connection(fields: ["assignmentIds"])

  "CourseSections' Ids"
  courseSectionIds: [String]

  "Sections in the course"
  sections: [CourseSection] @connection(fields: ["courseSectionIds"])

  "Search Field for searching the entire table for a string"
  searchField: String
}

"""
CourseSections belong to courses and contain assignments
"""
type CourseSection
  @model
  @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }]) {
  id: ID!

  "Name of the section"
  name: String!

  "Section number, helpful in determining the order in which it is to be listed"
  index: Float!

  "Course that this section belongs to"
  course: Course!
}

"""
Assignments are part of courses and need to be completed as part of the course
"""
type Assignment
  @model
  @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }]) {
  id: ID!

  "Title of the assignment"
  title: String!

  "Id of the course that this assignment belongs to"
  course: Course!

  "Id of the section that this assignment belongs to"
  section: CourseSection!

  "When this assignment is due"
  deadline: AWSDateTime

  "Total number of points available to score in this assignment"
  points: Int

  "A description of what needs to be done in the assignment"
  instructions: String

  "Task ids"
  taskIds: [String]

  "A list of tasks to be completed as part of this assignment"
  tasks: [Task] @connection(fields: ["taskIds"])
}

"""
Tasks to be completed as part of an assignment
INCOMPLETE
"""
type Task @model @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }]) {
  id: ID!

  "Description of the task"
  task: String!

  "An enum of the fixed list of types of tasks"
  type: String!
}

"""
Connection Table
This is a join table that ties courses with Instructors
This is the way to establish many-to-many relationships
"""
type CourseInstructor
  @model(queries: null)
  @key(name: "CourseInstructorConnection", fields: ["courseId", "instructorId"])
  @key(
    name: "InstructorCourseConnection"
    fields: ["instructorId", "courseId"]
  ) {
  id: ID!

  courseId: String!

  instructorId: String!

  "The course that this instructor belongs to"
  course: Course! @connection(fields: ["courseId"])

  "The instructor(s) in the course"
  instructor: Member! @connection(fields: ["instructorId"])
}

"""
Connection Table
This is a join table that ties courses with Assistants
This is the way to establish many-to-many relationships
"""
type CourseAssistant
  @model(queries: null)
  @key(name: "CourseAssistantConnection", fields: ["courseId", "assistantId"])
  @key(name: "AssistantCourseConnection", fields: ["assistantId", "courseId"]) {
  id: ID!

  courseId: String

  assistantId: String

  "The course that this instructor belongs to"
  course: Course @connection(fields: ["courseId"])

  "The instructor(s) in the course"
  assistant: Member @connection(field: ["assistantId"])
}

"""
Connection Table
This is a join table that ties courses with Learners
This is the way to establish many-to-many relationships
"""
type CourseLearner
  @model(queries: null)
  @key(name: "CourseLearnerConnection", fields: ["courseId", "learnerId"])
  @key(name: "LearnerCourseConnection", fields: ["learnerId", "courseId"]) {
  id: ID!

  courseId: String

  learnerId: String

  "The course that this instructor belongs to"
  course: Course @connection(fields: ["courseId"])

  "The instructor(s) in the course"
  learner: Member @connection(fields: ["learnerId"])
}

"""
Connection Table
This is a join table that ties groups with Members
This is the way to establish many-to-many relationships
"""
type GroupMember
  @model(queries: null)
  @key(name: "GroupMemberConnection", fields: ["groupId", "memberId"])
  @key(name: "MemberGroupConnection", fields: ["memberId", "groupId"]) {
  id: ID!

  groupId: String

  memberId: String

  "The group that the member belongs to"
  group: Group @connection(fields: ["grouppId"])

  "The members in the group"
  member: Member @connection(fields: ["memberId"])
}
